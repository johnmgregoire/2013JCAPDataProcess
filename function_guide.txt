GUIDE FOR WRITING FIGURE OF MERIT FUNCTIONS

When the function automator runs, it looks for a script called 'fomfunctions.py' in the version folder and runs all functions that are applicable to a file's experiment type on that file.  Each function in 'fomfunctions.py' should calculate a single figure of merit, and each function should be named after the value it calculates because the function name will be used to identify the figure of merit in the output files.  Here are some guidelines for writing functions that are compatible with our program:

1. Raw data and intermediate data (values that are calculated from raw data and used to compute figures of merit) are stored in dictionaries that can be given as positional arguments to figure of merit functions.  The first positional argument is always the raw data dictionary, and the intermediate data dictionary is the optional second positional argument.  The raw data dictionary is read-only; any modifications made to the dictionary while the program is running will not be stored permanently.  The intermediate data dictionary can be read from and written to by any functions that you write, and the values in this dictionary are stored in intermediate data files upon completing the analysis of each input file.
2. Any helper functions or functions that produce intermediate data should be saved in a separate module in the version folder and called by figure-of-merit producing functions.  The automator only runs the functions in 'fomfunctions.py,' and all functions in 'fomfunctions.py' have their return values saved by the program as figures of merit.
3. All arguments to figure-of-merit functions other than the raw and intermediate data dictionaries should be keyword arguments.  If multiple data columns can be used in calculating a figure of merit, the default value of the keyword argument should be a list of the names of data columns that can be used.  (The program calls these batch variables, and how to specify when to use each variable is explained below.)  Any keyword arguments with default string values are assumed to be keys in the raw or intermediate data dictionaries.  All other keyword arguments will use their default values in the function, and when the program is run through the GUI, these default values can be changed for that session.  The parameters used for each file (either default or input by the user) are saved in the intermediate data files.
4. In order to only perform relevant calculations for each type of experiment, there should be a dictionary defined at the top of the 'fomfunctions.py' file called EXPERIMENT_FUNCTIONS.  The keys in this dictionary should be the names of the experiments as they appear in the raw data files and the database, and the values in this dictionary are themselves dictionaries.  The dictionary for each experiment type should consist of the quoted names of the figure-of-merit functions to run for this experiment mapped to a list of the batch variables to use.  (If there are no batch variables for a particular function, use an empty list.)  Each item in this list itself also a list of the batch variables to select for a single calculation.  An example of EXPERIMENT_FUNCTIONS is:

EXPERIMENT_FUNCTIONS = {'CV': {'Max': [['I(A)'], ['I(A)_LinSub']], 'Min': [['I(A)'], ['I(A)_LinSub']],
                     'E_IThresh': [['I(A)'], ['I(A)_LinSub']],
                     'IllDiff': [['I(A)', 'max'], ['I(A)', 'min'],
                                 ['I(A)_LinSub', 'max'], ['I(A)_LinSub', 'min']]},
              'OCV': {'Final': [['Ewe(V)']], 'Avg': [['Ewe(V)']],
                      'ArrSS': [['Ewe(V)']], 'IllDiff': [['Ewe(V)', 'avg']]},
              'CP': {'Final': [['Ewe(V)']], 'Avg': [['Ewe(V)']],
                     'ArrSS': [['Ewe(V)']], 'IllDiff': [['Ewe(V)', 'avg']]},
              'CA': {'Final': [['I(A)']], 'Avg': [['I(A)']],
                     'ArrSS': [['I(A)']], 'IllDiff': [['I(A)', 'avg']]}}

Here, thisvar=['Ewe(V)', 'I(A)', 'I(A)_LinSub'] and fomName=['min', 'max', 'avg'] are two of the keyword arguments to IllDiff.  Notice how one variable is selected from each batch for each figure of merit calculation.
5. If there are both raw and intermediate data columns in a list of batch variables, your function can first check if the variable name is in the raw data dictionary and get that column from the dictionary; otherwise, it will get the column from the intermediate data dictionary.
6. If you want to calculate one figure of merit for each segment of an experiment, your figure of merit function can return a Python list.  The automator will save each value in the list as a separate figure of merit, labeled by index.  No other non-scalar figure of merit types are supported.
7. If one set of calculations produces multiple figures of merit, these values can be saved in the intermediate data dictionary by the first figure of merit function.  The remaining figures of merit can be returned to the automator from the intermediate data dictionary by accessor functions.
8. If a figure of merit cannot be calculated, the function should return float('nan').  Numpy.nan is not supported by the XML and JSON encodings for output files and will raise an exception.  Any NaN values in intermediate data should also be declared as float('nan').

WRITING A NEW VERSION OF FIGURE OF MERIT FUNCTIONS
1. fomfunctions.py should be from scratch
2. guidelines for fomfunctions_update.py (optional)
Whenever a new version of figure of merit functions is written, all files used for calculation, included helper functions and functions that produce intermediate data, should be saved in a version folder inside the directory that holds all versions of the functions.  The format of the version folder name should be YYYYMMDDX, where X is an integer representing the number of versions that have been committed that day, starting from 0.  The original version of the figure of merit functions will not have an update module; no subsequent versions are required to have an update module, but it makes calculations faster.  The requirements for the figure of merit function modules inside the version folder are explained below:

1. The most recent version of all figure of merit functions should be contained inside a file called 'fomfunctions.py.'  This will be called on all files for which there is no intermediate data from the previous version of the functions, or if no update module exists.
2. The update module should be named 'fomfunctions_update.py' and should contain only figure of merit functions that have been changed since the previous version.  The EXPERIMENT_FUNCTIONS dictionary in this file should only include functions that are in this file.
3. The new functions in 'fomfunctions_update.py' should be identical to their counterparts in 'fomfunctions.py.'  To ensure consistency between these two modules, all functions not in the update module should be identical to their counterparts in the previous version of 'fomfunctions.py.'  Make sure that you import any necessary helper function files and library modules inside both 'fomfunctions.py' and 'fomfunctions_update.py.'